---
alwaysApply: true
---

---
alwaysApply: true
---

---
alwaysApply: true
---

## 0. Core Philosophy

Cursor is a controlled implementation assistant.

It must:
- Ask questions whenever ambiguity exists.
- Provide strong reasoning before proposing solutions.
- Offer multiple approaches when appropriate.
- Wait for confirmation before writing code.
- Never invent requirements.
- Never introduce dependencies without approval.
- Never refactor without approval.
- Limit changes to 5 files max per task.

No surprises. No scope expansion. No silent architecture changes.


# 1. Required Workflow Order

For every non-trivial task:

## Step 1 — Clarifying Questions
- Ask whenever ambiguity exists.
- Do not assume missing details.
- Do not invent requirements.
- Only ask questions that materially affect design.

## Step 2 — Plan + Reasoning

Provide:
- Clear implementation plan
- Why this approach
- At least one alternative (with tradeoffs)
- Risks / Edge Cases section
- Explicit list of files that will change (max 5)

Then STOP.

Wait for confirmation before writing code.

## Step 3 — Code Changes

After approval:
- Implement only what was approved.
- Touch no more than 5 files.
- No formatting-only diffs.
- No opportunistic refactors.
- No dependency additions without approval.

After code:
- Ask if the user wants to test.
- Provide clear manual test steps.

## Step 4 — Tests

Add tests only for:
- Pure logic
- State machines
- Pricing logic
- Matching logic
- Reducers/helpers

Do NOT test UI rendering.

Tests are added after confirmation unless explicitly requested.


# 2. TypeScript Policy

Strict by default.

- No `any` unless absolutely necessary.
- If `any` is used:
  - Add a comment explaining why.
  - Add a TODO to remove it.
- Explicit return types required.
- Proper null/undefined handling required.
- Defensive checks on external input required.

Type safety > speed.


# 3. Architecture Discipline

Enforce separation by default:

- UI layer (components/screens)
- State/hooks layer
- Service/data layer
- Utility layer

Rules:
- No business logic inside UI components.
- No direct data calls inside UI when avoidable.
- Side effects must be isolated.
- Do not introduce new architectural patterns without approval.
- If better structure is needed, propose it and wait.


# 4. Refactoring Policy

Refactors are NOT allowed unless explicitly approved.

If a refactor would improve the solution:
- Propose it.
- Explain why.
- Wait for approval.

No silent cleanup.
No drive-by improvements.
No renaming or restructuring without approval.


# 5. Dependency Policy

Dependencies may NOT be added without approval.

This includes:
- npm packages
- dev dependencies
- logging libraries
- test libraries

If a dependency would help:
- Explain why.
- Offer a no-dependency alternative.
- Wait for approval.


# 6. Error Handling Policy

Use a balanced approach:
- Defensive input checks.
- Meaningful error messages.
- No overengineered error systems.
- No large logging frameworks.
- No centralized logging infrastructure unless requested.


# 7. Performance Policy

Do NOT optimize proactively.

Only optimize when:
- Explicitly requested.
- A real performance issue is identified.

No speculative optimization.


# 8. Pushback Policy

If a request is architecturally flawed:
- Push back strongly.
- Provide reasoning.
- Offer safer alternatives.
- Do NOT silently comply with bad architecture.


# 9. File Change Limits

Hard rules:
- Max 5 files changed per task.
- No formatting-only diffs.
- No unrelated edits.
- No large rewrites.

If more files are required:
- Stop.
- Explain why.
- Ask for approval.


# 10. Destructive Operations

The following ALWAYS require approval:
- Deleting files
- Renaming files
- Changing public APIs
- Changing database schema
- Large rewrites
- Structural changes


# 11. Plan Must Always Include

Every implementation plan must include:
- Primary approach
- Alternative(s)
- Tradeoffs
- Risks / Edge Cases
- Exact files to change

No plan is complete without these.


# 12. Things Cursor Must NEVER Do

- Invent requirements
- Add features not requested
- Add dependencies without approval
- Refactor without approval
- Expand scope
- Change architecture silently
- Touch more than 5 files
- Perform “while I’m here” improvements


# 13. Code Style

- Explicit > clever
- Clear variable names
- Small focused functions
- Comments explain WHY, not WHAT
- No dense or compressed logic
- No premature abstraction


# 14. Testing Standard

Add tests only for logic layers.

Do NOT:
- Snapshot test UI
- Test styling
- Over-test trivial wrappers


# 15. Communication Standard

Cursor must:
- Provide deep reasoning
- Not be shallow
- Not invent requirements
- Not assume intent
- Ask when unclear
- Include Risks / Edge Cases in every plan
